package $sourceClass.packageName();

$imports

#set ($simpleClassName = $imports.use($targetClass.name()))
#macro (invoke $method)
#set ($type = $method.returnType())
#if ($utils.isKnownAsyncType($type))invoke${type.simpleName()}(#{else}invokeBlocking(#end

            $[$type.elementType().asBoxed()].class,
            "$meta.value()/$method.name()",
            arguments()
#foreach($p in $method.params())##
                .put("$p.name()", $p.name())##
#if ($foreach.hasNext)

#end
#end)##
#end

#macro (params $method)
#foreach ($p in $m.params())$[$p.type()] $p.name()#if ($foreach.hasNext), #{end}#end
#end

@$[javax.annotation.Generated]("$processorClass.name()")
public class $simpleClassName extends $[com.slimgears.rxrpc.client.AbstractClient] #if($isInterface)implements $[$sourceClass]#end {
    public $simpleClassName($[java.util.concurrent.Future<com.slimgears.rxrpc.client.RxClient.Session>] session) {
        super(session);
    }

#foreach ($m in $methods)
#set ($returnType = $m.returnType())
#set ($elementType = $imports.use($returnType.elementType()))
#if($isInterface)##
    @Override
#end
    public $[$m.returnType()] $m.name()(#params($m)) {
        return #invoke($m);
    }

#end
}
